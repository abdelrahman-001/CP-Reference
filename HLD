const int N = 1e5 + 5;
const int lg = 20;
int n , q , sz[N];
vector<int> g[N];
int lvl[N] , sp[N][lg];
void dfs(int node , int par) {
    lvl[node] = lvl[par] + 1;
    sp[node][0] = par;
    for(int i = 1;i < lg;i++) {
        int tmp = sp[node][i - 1];
        sp[node][i] = sp[tmp][i - 1];
    }
    sz[node] = 1;
    for(auto &i : g[node]) {
        if(i == par)
            continue;
        dfs(i , node);
        sz[node] += sz[i];
    }
}
int get_kth(int u , int k) {
    for(int i = 0;i < lg;i++)
        if((1 << i) & k)
            u = sp[u][i];
    return u;
}
int get_lca(int u , int v) {
    if(lvl[v] < lvl[u])
        swap(u , v);
    v = get_kth(v , lvl[v] - lvl[u]);
    if(u == v)
        return u;
    for(int i = lg - 1;i >= 0;i--)
        if(sp[u][i] != sp[v][i])
            u = sp[u][i] , v = sp[v][i];
    return sp[u][0];
}
int chainID , ind , head[N] , node_chain[N] , pos[N];
void HLD(int node , int par) {
    if(head[chainID] == -1)
        head[chainID] = node;
    node_chain[node] = chainID;
    pos[node] = ind++;
    int mx = 0 , heavy = -1;
    for(auto &i : g[node])
        if(i != par && sz[i] > mx)
            mx = sz[i] , heavy = i;
    if(heavy != -1)
        HLD(heavy , node);
    for(auto &i : g[node])
        if(i != par && i != heavy)
            chainID++ , HLD(i , node);
}
int seg[4 * N];
int query_mx(int node , int s , int e , int l , int r) {
    if(s > r || e < l)
        return 0;
    if(l <= s && e <= r)
        return seg[node];
    int mid = s + e >> 1;
    return max(query_mx(node << 1 , s , mid , l , r) , query_mx(node << 1 | 1 , mid + 1 , e , l , r));
}
int query(int u , int v) {
    int ans = 0;
    while(1) {
        if(lvl[u] < lvl[v])
            swap(u , v);
        int u_chain = node_chain[u] , v_chain = node_chain[v];
        if(u_chain == v_chain) {
            if(pos[u] > pos[v])
                swap(u , v);
            int val = query_mx(1 , 0 , n - 1 , pos[u] , pos[v]);
            ans = max(ans , val);
            break;
        }
        int val = query_mx(1 , 0 , n - 1 , pos[head[u_chain]] , pos[u]);
        ans = max(ans , val);
        u = sp[head[u_chain]][0];
    }
    return ans;
}
int get(int u , int v) {
    int lca = get_lca(u , v);
    return max(query(u , lca) , query(lca , v));
}
void update(int node , int s , int e , int i , int val) {
    if(s == e) {
        seg[node] += val;
        return;
    }
    int mid = s + e >> 1;
    if(i <= mid)
        update(node << 1 , s , mid , i , val);
    else
        update(node << 1 | 1 , mid + 1 , e , i , val);
    seg[node] = max(seg[node << 1] , seg[node << 1 | 1]);
}
