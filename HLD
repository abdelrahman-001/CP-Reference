#pragma GCC optimize ("O3")
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5;
const int lg = 20;
int t , n , sz[N];
vector<pair<int , int>> edges;
vector<pair<int , int>> g[N];
int lvl[N] , sp[N][lg];
void dfs(int node , int par) {
    lvl[node] = lvl[par] + 1;
    sp[node][0] = par;
    for(int i = 1;i < lg;i++) {
        int tmp = sp[node][i - 1];
        sp[node][i] = sp[tmp][i - 1];
    }
    sz[node] = 1;
    for(auto &i : g[node]) {
        if(i.first == par)
            continue;
        dfs(i.first , node);
        sz[node] += sz[i.first];
    }
}
int get_kth(int u , int k) {
    for(int i = 0;i < lg;i++)
        if((1 << i) & k)
            u = sp[u][i];
    return u;
}
int get_lca(int u , int v) {
    if(lvl[v] < lvl[u])
        swap(u , v);
    v = get_kth(v , lvl[v] - lvl[u]);
    if(u == v)
        return u;
    for(int i = lg - 1;i >= 0;i--)
        if(sp[u][i] != sp[v][i])
            u = sp[u][i] , v = sp[v][i];
    return sp[u][0];
}
int chainID , ind , head[N] , node_chain[N] , pos[N] , a[N];
void HLD(int node , int par , int cost) {
    if(head[chainID] == -1)
        head[chainID] = node;
    node_chain[node] = chainID;
    pos[node] = ind , a[ind++] = cost;
    pair<int , int> heavy = {-1 , 0};
    int mx = 0;
    for(auto &i : g[node])
        if(i.first != par && sz[i.first] > mx)
            mx = sz[i.first] , heavy = i;
    if(heavy.first != -1)
        HLD(heavy.first , node , heavy.second);
    for(auto &i : g[node])
        if(i.first != par && i != heavy)
            chainID++ , HLD(i.first , node , i.second);
}
int seg[4 * N];
void build(int node , int s , int e) {
    if(s == e) {
        seg[node] = a[s];
        return;
    }
    int mid = s + e >> 1;
    build(node << 1 , s , mid);
    build(node << 1 | 1 , mid + 1 , e);
    seg[node] = max(seg[node << 1] , seg[node << 1 | 1]);
}
int query_mx(int node , int s , int e , int l , int r) {
    if(s > r || e < l)
        return 0;
    if(l <= s && e <= r)
        return seg[node];
    int mid = s + e >> 1;
    return max(query_mx(node << 1 , s , mid , l , r) , query_mx(node << 1 | 1 , mid + 1 , e , l , r));
}
int query(int u , int v) {
    int ans = 0;
    while(u != v) {
        if(lvl[u] < lvl[v])
            swap(u , v);
        int u_chain = node_chain[u] , v_chain = node_chain[v];
        if(u_chain == v_chain) {
            if(pos[u] > pos[v])
                swap(u , v);
            int val = query_mx(1 , 0 , n - 1 , pos[u] + 1 , pos[v]);
            ans = max(ans , val);
            break;
        }
        int val = query_mx(1 , 0 , n - 1 , pos[head[u_chain]] , pos[u]);
        ans = max(ans , val);
        u = sp[head[u_chain]][0];
    }
    return ans;
}
int get(int u , int v) {
    int lca = get_lca(u , v);
    return max(query(u , lca) , query(lca , v));
}
void update(int node , int s , int e , int i , int val) {
    if(s == e) {
        seg[node] = val;
        return;
    }
    int mid = s + e >> 1;
    if(i <= mid)
        update(node << 1 , s , mid , i , val);
    else
        update(node << 1 | 1 , mid + 1 , e , i , val);
    seg[node] = max(seg[node << 1] , seg[node << 1 | 1]);
}
void init() {
    edges.clear();
    chainID = ind = 0;
    for(int i = 0;i <= n;i++) {
        g[i].clear();
        sz[i] = 0 , head[i] = -1;
    }
    for(int i = 0;i <= 4 * n;i++)
        seg[i] = 0;
}
int main() {
    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin >> t;
    while(t--) {
        cin >> n;
        init();
        for(int i = 1;i < n;i++) {
            int u , v , c;
            cin >> u >> v >> c;
            g[u].push_back({v , c});
            g[v].push_back({u , c});
            edges.push_back({u , v});
        }
        dfs(1 , 1);
        HLD(1 , 1 , 0);
        build(1 , 0 , n - 1);
        string s;
        cin >> s;
        while(s != "DONE") {
            int x , y;
            cin >> x >> y;
            if(s[0] == 'Q')
                cout << get(x , y) << '\n';
            else {
                int u = edges[x - 1].first , v = edges[x - 1].second;
                int node = (lvl[u] > lvl[v]) ? u : v;
                update(1 , 0 , n - 1 , pos[node] , y);
            }
            cin >> s;
        }
    }
    return 0;
}
