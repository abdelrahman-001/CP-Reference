mt19937_64 mrand(chrono::steady_clock::now().time_since_epoch().count());
struct Node {
    int key, pri = mrand(), sz = 1;
    int lz = 0;
    bool rev = false; ///rev^=1;
    array<Node * 2, int> c[2];
    Node(int key) : key(key){}
};
int getsz(Node * t){return t?t->sz:0;}
Node * calc(Node * t) {
    t->sz = 1 + getsz(t->c[0]) + getsz(t->c[1]);
    return t;
}
array<Node*, 2> split(Node * t, int k) {
    if(!t)
        return {t, t};
    if(getsz(t->c[0]) >= k) {   ///answer is in left node
        auto ret = split(t->c[0], k);
        t->c[0] = ret[1];
        return {ret[0], calc(t)};
    }   else {  ///k > t->c[0]
        auto ret = split(t->c[1], k - 1 - getsz(t->c[0]));
        t->c[1] = ret[0];
        return {calc(t), ret[1]};
    }
}

Node * merge(Node * u, Node * v) {
    if(!u||!v)
        return u?u:v;
    if(u->pri>v->pri) {
        u->c[1]=merge(u->c[1], v);
        return calc(u);
    }   else {
        v->c[0]=merge(u, v->c[0]);
        return calc(v);
    }
}
